name: Build Modules

on:
  workflow_call:
    inputs:
      from_ci:
        type: boolean
        required: false
        default: true
      notify_telegram:
        type: boolean
        required: false
        default: false
  workflow_dispatch:
    inputs:
      notify_telegram:
        description: "Send Telegram Notification"
        type: boolean
        default: true

jobs:
  run:
    permissions: write-all
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-java@v4
        with:
          distribution: "zulu"
          java-version: "17"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true

      - name: Update config
        if: ${{ inputs.from_ci }}
        env:  
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if git checkout origin/update build.md; then
            UPDATE_CFG=$(./build.sh config.toml --config-update)
            if [ "$UPDATE_CFG" ]; then
              echo "$UPDATE_CFG" > config.json
            fi
          fi

      - name: Get next version code
        id: next_ver_code
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG=$(gh release list -L 1 | awk -F '\t' '{print $3}')
          if [ -z "$TAG" ]; then TAG=0; fi
          echo "NEXT_VER_CODE=$((TAG + 1))" >> $GITHUB_OUTPUT

      - name: Build modules/APKs
        run: if [ -f "config.json" ]; then ./build.sh config.json; else ./build.sh config.toml; fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: $GITHUB_REPOSITORY
          NEXT_VER_CODE: ${{ steps.next_ver_code.outputs.NEXT_VER_CODE }}

      - name: Get output
        id: get_output
        run: |
          DELIM="$(openssl rand -hex 8)"
          echo "BUILD_LOG<<${DELIM}" >> "$GITHUB_OUTPUT"
          cat build.md >> "$GITHUB_OUTPUT"
          echo "${DELIM}" >> "$GITHUB_OUTPUT"
          cp -f build.md build.tmp

      - name: Upload modules to release
        uses: svenstaro/upload-release-action@v2
        with:
          body: ${{ steps.get_output.outputs.BUILD_LOG }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: ./build/*
          release_name: ReVanced
          tag: ${{ steps.next_ver_code.outputs.NEXT_VER_CODE }}
          file_glob: true
          overwrite: true

      - name: Update changelog and Magisk update json
        id: update_config
        run: |
          git checkout -f update || git switch --discard-changes --orphan update
          cp -f build.tmp build.md

          get_update_json() {
            echo "{
              \"version\": \"$1\",
              \"versionCode\": ${{ steps.next_ver_code.outputs.NEXT_VER_CODE }},
              \"zipUrl\": \"$2\",
              \"changelog\": \"https://raw.githubusercontent.com/$GITHUB_REPOSITORY/update/build.md\"
            }"
          }

          cd build || { echo "build folder not found"; exit 1; }

          for OUTPUT in *magisk*.zip; do
            [ "$OUTPUT" = "*magisk*.zip" ] && continue
            ZIP_S=$(unzip -p "$OUTPUT" module.prop)
            if ! UPDATE_JSON=$(echo "$ZIP_S" | grep updateJson); then continue; fi
            UPDATE_JSON="${UPDATE_JSON##*/}"
            VER=$(echo "$ZIP_S" | grep version=)
            VER="${VER##*=}"
            DLURL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/releases/download/${{ steps.next_ver_code.outputs.NEXT_VER_CODE }}/${OUTPUT}"
            get_update_json "$VER" "$DLURL" >"../$UPDATE_JSON"
          done

          cd ..
          find . -name "*-update.json" | grep . || : >dummy-update.json

      - name: Write versions.json from build.md
        env:
          NEXT_VER_CODE: ${{ steps.next_ver_code.outputs.NEXT_VER_CODE }}
        run: |
          set -e
          # Parse versions and component refs from build.md for deterministic snapshot
          test -f build.md

          GP64=$(grep -E '^GooglePhotos \(arm64-v8a\):' build.md | awk -F': ' '{print $2}' | head -n1 || true)
          GP32=$(grep -E '^GooglePhotos \(arm-v7a\):' build.md | awk -F': ' '{print $2}' | head -n1 || true)
          MX64=$(grep -E '^Music-Extended \(arm64-v8a\):' build.md | awk -F': ' '{print $2}' | head -n1 || true)
          MX32=$(grep -E '^Music-Extended \(arm-v7a\):' build.md | awk -F': ' '{print $2}' | head -n1 || true)
          YT=$(grep -E '^YouTube:' build.md | awk -F': ' '{print $2}' | head -n1 || true)

          CLI_REV=$(grep -E '^CLI:\s*j-hc/revanced-cli-[^ ]+\.jar' -m1 -o build.md | sed 's/^CLI:\s*//' || true)
          CLI_INO=$(grep -E '^CLI:\s*inotia00/revanced-cli-[^ ]+\.jar' -m1 -o build.md | sed 's/^CLI:\s*//' || true)

          PATCH_REV=$(grep -E '^Patches:\s*ReVanced/patches-[^ ]+\.rvp' -m1 -o build.md | sed 's/^Patches:\s*//' || true)
          PATCH_INO=$(grep -E '^Patches:\s*inotia00/patches-[^ ]+\.rvp' -m1 -o build.md | sed 's/^Patches:\s*//' || true)

          GP64=${GP64:-""}; GP32=${GP32:-""}; MX64=${MX64:-""}; MX32=${MX32:-""}; YT=${YT:-""}
          CLI_REV=${CLI_REV:-""}; CLI_INO=${CLI_INO:-""}
          PATCH_REV=${PATCH_REV:-""}; PATCH_INO=${PATCH_INO:-""}

          TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          cat > versions.json <<JSON
          {
            "generatedAt": "${TS}",
            "versionCode": ${NEXT_VER_CODE},
            "apps": {
              "GooglePhotos": {
                "arm64-v8a": "${GP64}",
                "arm-v7a":   "${GP32}"
              },
              "Music-Extended": {
                "arm64-v8a": "${MX64}",
                "arm-v7a":   "${MX32}"
              },
              "YouTube": "${YT}"
            },
            "cli": {
              "revanced": "${CLI_REV}",
              "inotia00": "${CLI_INO}"
            },
            "patches": {
              "revanced": "${PATCH_REV}",
              "inotia00": "${PATCH_INO}"
            }
          }
          JSON

      - uses: stefanzweifel/git-auto-commit-action@v5
        with:
          branch: update
          skip_checkout: true
          file_pattern: build.md *-update.json versions.json
          commit_message: Bump version ${{ steps.next_ver_code.outputs.NEXT_VER_CODE }}

      - name: Report to Telegram
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        if: env.TG_TOKEN != null && (inputs.notify_telegram == true)
        run: |  
          set -euo pipefail  
          cd build || { echo "build folder not found"; exit 1; }  
        
          # Build download lists 
          TG_CHAT="${TG_CHAT_ID}"
          NL=$'\n'  
          APKS="" 
          MODULES=""
          
          for OUTPUT in *; do  
            DL_URL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/releases/download/${{ steps.next_ver_code.outputs.NEXT_VER_CODE }}/${OUTPUT}"  
            if [[ $OUTPUT = *.apk ]]; then  
              APKS+="${NL}${OUTPUT} -> ${DL_URL}"  
            elif [[ $OUTPUT = *.zip ]]; then  
              MODULES+="${NL}${OUTPUT} -> ${DL_URL}"  
            fi  
          done  
          MODULES=${MODULES#"$NL"}  
          APKS=${APKS#"$NL"}  
        
          # Prepare body from build.md, convert to Telegram Markdown-friendly  
          BODY="$(sed 's/^\* \*\*/↪ \*\*/g; s/^\* `/↪ \*\*/g; s/`/\*/g; s/^\* /\↪/g; s/\*\*/\*/g; s/###//g; s/^- /↪ /g; /^==/d;' ../build.md)"  
        
          MSG="*New build!*"  
          ${BODY}
          *▼ Download Links:*
          Modules:
          ${MODULES}          
          APKs:
          ${APKS}
          "

          # Telegram API  
          POST="https://api.telegram.org/bot${TG_TOKEN}/sendMessage"

          # Trim to Telegram size limit safety margin  
          MSG=${MSG:0:9450}
          
          # Send request; keep curl as a single command with all args  
          HTTP_CODE=$(curl -sS -w "%{http_code}" -o /tmp/tg_resp.json \  
            -X POST \  
            --data-urlencode "parse_mode=Markdown" \  
            --data-urlencode "disable_web_page_preview=true" \  
            --data-urlencode "text=${MSG}" \  
            --data-urlencode "chat_id=${TG_CHAT}" \  
            "$POST" || true)
            
          echo "Telegram HTTP ${HTTP_CODE}"  
          echo "Telegram response:"  
          cat /tmp/tg_resp.json || true

          # Consider non-2xx a soft failure; do not fail the whole job  
          case "$HTTP_CODE" in  
            2*) exit 0 ;;  
            *)  echo "Warning: Telegram post failed (HTTP ${HTTP_CODE})" ;;  
          esac
