name: Daily 5am

on:
  schedule:
    # Cover both DST states; gate ensures only 05:00 local proceeds
    - cron: '0 18 * * *'  # 05:00 AEDT (UTC+11)
    - cron: '0 19 * * *'  # 05:00 AEST (UTC+10)
  workflow_dispatch:

concurrency:
  group: daily-5am-sydney
  cancel-in-progress: false

jobs:
  gate:
    runs-on: ubuntu-latest
    outputs:
      run: ${{ steps.gate.outputs.run }}
    steps:
      - name: Gate to only run at 05:00 Australia/Sydney (or always for manual)
        id: gate
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Manual dispatch - allowing run"
            echo "run=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          export TZ=Australia/Sydney
          NOW_HOUR="$(date +%H)"
          NOW_MINUTE="$(date +%M)"
          echo "Local time in Australia/Sydney: ${NOW_HOUR}:${NOW_MINUTE}"
          
          # Check if it's the 5 AM hour  
          if [ "$NOW_HOUR" = "05" ]; then  
            echo "Current time is within the 5 AM hour; allowing run."  
            echo "run=true" >> $GITHUB_OUTPUT  
          else  
            echo "Current time is outside the 5 AM hour; skipping."  
            echo "run=false" >> $GITHUB_OUTPUT  
          fi

  check-updates:
    needs: gate
    if: needs.gate.outputs.run == 'true'
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.decide.outputs.proceed }}
      next_ver_code: ${{ steps.next_ver_code.outputs.NEXT_VER_CODE }}
    steps:
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '17'

      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true

      - name: Load last-built versions.json from update branch (if present)
        id: last
        run: |
          set -e
          git fetch origin update:update || true
          if git show update:versions.json >/dev/null 2>&1; then
            git show update:versions.json > last_versions.json
            echo "found_json=true" >> $GITHUB_OUTPUT
          else
            echo "found_json=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate latest snapshot via build.sh (config update)
        id: latest
        run: |
          set -e
          # Try to detect latest versions via your existing mechanism
          # If this step leaves a build.md, parse it; otherwise fallback to empty strings
          ./build.sh config.toml --config-update >/dev/null 2>&1 || true

          GP64=""; GP32=""; MX64=""; MX32=""; YT=""
          CLI_REV=""; CLI_INO=""; PATCH_REV=""; PATCH_INO=""

          if [ -f build.md ]; then
            GP64=$(grep -E '^GooglePhotos \(arm64-v8a\):' build.md | awk -F': ' '{print $2}' | head -n1 || true)
            GP32=$(grep -E '^GooglePhotos \(arm-v7a\):' build.md | awk -F': ' '{print $2}' | head -n1 || true)
            MX64=$(grep -E '^Music-Extended \(arm64-v8a\):' build.md | awk -F': ' '{print $2}' | head -n1 || true)
            MX32=$(grep -E '^Music-Extended \(arm-v7a\):' build.md | awk -F': ' '{print $2}' | head -n1 || true)
            YT=$(grep -E '^YouTube:' build.md | awk -F': ' '{print $2}' | head -n1 || true)

            CLI_REV=$(grep -E '^CLI:\s*j-hc/revanced-cli-[^ ]+\.jar' -m1 -o build.md | sed 's/^CLI:\s*//' || true)
            CLI_INO=$(grep -E '^CLI:\s*inotia00/revanced-cli-[^ ]+\.jar' -m1 -o build.md | sed 's/^CLI:\s*//' || true)

            PATCH_REV=$(grep -E '^Patches:\s*ReVanced/patches-[^ ]+\.rvp' -m1 -o build.md | sed 's/^Patches:\s*//' || true)
            PATCH_INO=$(grep -E '^Patches:\s*inotia00/patches-[^ ]+\.rvp' -m1 -o build.md | sed 's/^Patches:\s*//' || true)
          fi

          TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          cat > latest.json <<JSON
          {
            "generatedAt": "${TS}",
            "apps": {
              "GooglePhotos": {
                "arm64-v8a": "${GP64}",
                "arm-v7a":   "${GP32}"
              },
              "Music-Extended": {
                "arm64-v8a": "${MX64}",
                "arm-v7a":   "${MX32}"
              },
              "YouTube": "${YT}"
            },
            "cli": {
              "revanced": "${CLI_REV}",
              "inotia00": "${CLI_INO}"
            },
            "patches": {
              "revanced": "${PATCH_REV}",
              "inotia00": "${PATCH_INO}"
            }
          }
          JSON

          echo "Latest snapshot:"
          cat latest.json

      - name: Decide whether to proceed (strict compare)
        id: decide
        run: |
          set -e
          # Always proceed for manual runs
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Manual run â€” proceeding."
            echo "proceed=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Proceed if we don't have a previous versions.json
          if [ "${{ steps.last.outputs.found_json }}" != "true" ]; then
            echo "No previous versions.json found; proceeding."
            echo "proceed=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Use jq if available for structured comparison; fallback to text diff
          if command -v jq >/dev/null 2>&1; then
            DIFF=$(jq --argfile a last_versions.json --argfile b latest.json -n '
              def norm(x): if x == null then "" else x end;
              def sanitize(obj):
                {
                  apps: {
                    GooglePhotos: {
                      "arm64-v8a": norm(obj.apps.GooglePhotos["arm64-v8a"]),
                      "arm-v7a":   norm(obj.apps.GooglePhotos["arm-v7a"])
                    },
                    "Music-Extended": {
                      "arm64-v8a": norm(obj.apps["Music-Extended"]["arm64-v8a"]),
                      "arm-v7a":   norm(obj.apps["Music-Extended"]["arm-v7a"])
                    },
                    YouTube: norm(obj.apps.YouTube)
                  },
                  cli: {
                    revanced: norm(obj.cli.revanced),
                    inotia00: norm(obj.cli.inotia00)
                  },
                  patches: {
                    revanced: norm(obj.patches.revanced),
                    inotia00: norm(obj.patches.inotia00)
                  }
                }';
              (sanitize($a) == sanitize($b)) | not
            ')
            if [ "$DIFF" = "true" ]; then
              echo "Detected differences from last build; proceeding."
              echo "proceed=true" >> $GITHUB_OUTPUT
            else
              echo "No differences; skipping build."
              echo "proceed=false" >> $GITHUB_OUTPUT
            fi
          else
            if diff -u last_versions.json latest.json >/dev/null 2>&1; then
              echo "No differences; skipping build."
              echo "proceed=false" >> $GITHUB_OUTPUT
            else
              echo "Detected differences from last build; proceeding."
              echo "proceed=true" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Get next version code (for reuse)
        id: next_ver_code
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG=$(gh release list -L 1 | awk -F '\t' '{print $3}')
          if [ -z "$TAG" ]; then TAG=0; fi
          echo "NEXT_VER_CODE=$((TAG + 1))" >> $GITHUB_OUTPUT

  run-build:
    needs: [gate, check-updates]
    if: needs.check-updates.outputs.proceed == 'true'
    permissions: write-all
    uses: ./.github/workflows/build.yml
    with:
      from_ci: true
